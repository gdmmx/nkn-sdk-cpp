// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pb/transaction.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_pb_2ftransaction_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_pb_2ftransaction_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_pb_2ftransaction_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_pb_2ftransaction_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[15]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_pb_2ftransaction_2eproto;
namespace pb {
class Coinbase;
struct CoinbaseDefaultTypeInternal;
extern CoinbaseDefaultTypeInternal _Coinbase_default_instance_;
class DeleteName;
struct DeleteNameDefaultTypeInternal;
extern DeleteNameDefaultTypeInternal _DeleteName_default_instance_;
class GenerateID;
struct GenerateIDDefaultTypeInternal;
extern GenerateIDDefaultTypeInternal _GenerateID_default_instance_;
class IssueAsset;
struct IssueAssetDefaultTypeInternal;
extern IssueAssetDefaultTypeInternal _IssueAsset_default_instance_;
class NanoPay;
struct NanoPayDefaultTypeInternal;
extern NanoPayDefaultTypeInternal _NanoPay_default_instance_;
class Payload;
struct PayloadDefaultTypeInternal;
extern PayloadDefaultTypeInternal _Payload_default_instance_;
class Program;
struct ProgramDefaultTypeInternal;
extern ProgramDefaultTypeInternal _Program_default_instance_;
class RegisterName;
struct RegisterNameDefaultTypeInternal;
extern RegisterNameDefaultTypeInternal _RegisterName_default_instance_;
class SigChainTxn;
struct SigChainTxnDefaultTypeInternal;
extern SigChainTxnDefaultTypeInternal _SigChainTxn_default_instance_;
class Subscribe;
struct SubscribeDefaultTypeInternal;
extern SubscribeDefaultTypeInternal _Subscribe_default_instance_;
class Transaction;
struct TransactionDefaultTypeInternal;
extern TransactionDefaultTypeInternal _Transaction_default_instance_;
class TransferAsset;
struct TransferAssetDefaultTypeInternal;
extern TransferAssetDefaultTypeInternal _TransferAsset_default_instance_;
class TransferName;
struct TransferNameDefaultTypeInternal;
extern TransferNameDefaultTypeInternal _TransferName_default_instance_;
class UnsignedTx;
struct UnsignedTxDefaultTypeInternal;
extern UnsignedTxDefaultTypeInternal _UnsignedTx_default_instance_;
class Unsubscribe;
struct UnsubscribeDefaultTypeInternal;
extern UnsubscribeDefaultTypeInternal _Unsubscribe_default_instance_;
}  // namespace pb
PROTOBUF_NAMESPACE_OPEN
template<> ::pb::Coinbase* Arena::CreateMaybeMessage<::pb::Coinbase>(Arena*);
template<> ::pb::DeleteName* Arena::CreateMaybeMessage<::pb::DeleteName>(Arena*);
template<> ::pb::GenerateID* Arena::CreateMaybeMessage<::pb::GenerateID>(Arena*);
template<> ::pb::IssueAsset* Arena::CreateMaybeMessage<::pb::IssueAsset>(Arena*);
template<> ::pb::NanoPay* Arena::CreateMaybeMessage<::pb::NanoPay>(Arena*);
template<> ::pb::Payload* Arena::CreateMaybeMessage<::pb::Payload>(Arena*);
template<> ::pb::Program* Arena::CreateMaybeMessage<::pb::Program>(Arena*);
template<> ::pb::RegisterName* Arena::CreateMaybeMessage<::pb::RegisterName>(Arena*);
template<> ::pb::SigChainTxn* Arena::CreateMaybeMessage<::pb::SigChainTxn>(Arena*);
template<> ::pb::Subscribe* Arena::CreateMaybeMessage<::pb::Subscribe>(Arena*);
template<> ::pb::Transaction* Arena::CreateMaybeMessage<::pb::Transaction>(Arena*);
template<> ::pb::TransferAsset* Arena::CreateMaybeMessage<::pb::TransferAsset>(Arena*);
template<> ::pb::TransferName* Arena::CreateMaybeMessage<::pb::TransferName>(Arena*);
template<> ::pb::UnsignedTx* Arena::CreateMaybeMessage<::pb::UnsignedTx>(Arena*);
template<> ::pb::Unsubscribe* Arena::CreateMaybeMessage<::pb::Unsubscribe>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace pb {

enum PayloadType : int {
  COINBASE_TYPE = 0,
  TRANSFER_ASSET_TYPE = 1,
  SIG_CHAIN_TXN_TYPE = 2,
  REGISTER_NAME_TYPE = 3,
  TRANSFER_NAME_TYPE = 4,
  DELETE_NAME_TYPE = 5,
  SUBSCRIBE_TYPE = 6,
  UNSUBSCRIBE_TYPE = 7,
  GENERATE_ID_TYPE = 8,
  NANO_PAY_TYPE = 9,
  ISSUE_ASSET_TYPE = 10,
  GENERATE_ID_2_TYPE = 11,
  PayloadType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PayloadType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PayloadType_IsValid(int value);
constexpr PayloadType PayloadType_MIN = COINBASE_TYPE;
constexpr PayloadType PayloadType_MAX = GENERATE_ID_2_TYPE;
constexpr int PayloadType_ARRAYSIZE = PayloadType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PayloadType_descriptor();
template<typename T>
inline const std::string& PayloadType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PayloadType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PayloadType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PayloadType_descriptor(), enum_t_value);
}
inline bool PayloadType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PayloadType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PayloadType>(
    PayloadType_descriptor(), name, value);
}
// ===================================================================

class UnsignedTx final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.UnsignedTx) */ {
 public:
  inline UnsignedTx() : UnsignedTx(nullptr) {}
  ~UnsignedTx() override;
  explicit constexpr UnsignedTx(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnsignedTx(const UnsignedTx& from);
  UnsignedTx(UnsignedTx&& from) noexcept
    : UnsignedTx() {
    *this = ::std::move(from);
  }

  inline UnsignedTx& operator=(const UnsignedTx& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnsignedTx& operator=(UnsignedTx&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnsignedTx& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnsignedTx* internal_default_instance() {
    return reinterpret_cast<const UnsignedTx*>(
               &_UnsignedTx_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(UnsignedTx& a, UnsignedTx& b) {
    a.Swap(&b);
  }
  inline void Swap(UnsignedTx* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnsignedTx* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UnsignedTx* New() const final {
    return new UnsignedTx();
  }

  UnsignedTx* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UnsignedTx>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnsignedTx& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UnsignedTx& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnsignedTx* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.UnsignedTx";
  }
  protected:
  explicit UnsignedTx(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 4,
    kPayloadFieldNumber = 1,
    kNonceFieldNumber = 2,
    kFeeFieldNumber = 3,
  };
  // bytes attributes = 4;
  void clear_attributes();
  const std::string& attributes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attributes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attributes();
  PROTOBUF_MUST_USE_RESULT std::string* release_attributes();
  void set_allocated_attributes(std::string* attributes);
  private:
  const std::string& _internal_attributes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attributes(const std::string& value);
  std::string* _internal_mutable_attributes();
  public:

  // .pb.Payload payload = 1;
  bool has_payload() const;
  private:
  bool _internal_has_payload() const;
  public:
  void clear_payload();
  const ::pb::Payload& payload() const;
  PROTOBUF_MUST_USE_RESULT ::pb::Payload* release_payload();
  ::pb::Payload* mutable_payload();
  void set_allocated_payload(::pb::Payload* payload);
  private:
  const ::pb::Payload& _internal_payload() const;
  ::pb::Payload* _internal_mutable_payload();
  public:
  void unsafe_arena_set_allocated_payload(
      ::pb::Payload* payload);
  ::pb::Payload* unsafe_arena_release_payload();

  // uint64 nonce = 2;
  void clear_nonce();
  ::PROTOBUF_NAMESPACE_ID::uint64 nonce() const;
  void set_nonce(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_nonce() const;
  void _internal_set_nonce(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // int64 fee = 3;
  void clear_fee();
  ::PROTOBUF_NAMESPACE_ID::int64 fee() const;
  void set_fee(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_fee() const;
  void _internal_set_fee(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:pb.UnsignedTx)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attributes_;
  ::pb::Payload* payload_;
  ::PROTOBUF_NAMESPACE_ID::uint64 nonce_;
  ::PROTOBUF_NAMESPACE_ID::int64 fee_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pb_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class Transaction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.Transaction) */ {
 public:
  inline Transaction() : Transaction(nullptr) {}
  ~Transaction() override;
  explicit constexpr Transaction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Transaction(const Transaction& from);
  Transaction(Transaction&& from) noexcept
    : Transaction() {
    *this = ::std::move(from);
  }

  inline Transaction& operator=(const Transaction& from) {
    CopyFrom(from);
    return *this;
  }
  inline Transaction& operator=(Transaction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Transaction& default_instance() {
    return *internal_default_instance();
  }
  static inline const Transaction* internal_default_instance() {
    return reinterpret_cast<const Transaction*>(
               &_Transaction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Transaction& a, Transaction& b) {
    a.Swap(&b);
  }
  inline void Swap(Transaction* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Transaction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Transaction* New() const final {
    return new Transaction();
  }

  Transaction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Transaction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Transaction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Transaction& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Transaction* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.Transaction";
  }
  protected:
  explicit Transaction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProgramsFieldNumber = 2,
    kUnsignedTxFieldNumber = 1,
  };
  // repeated .pb.Program programs = 2;
  int programs_size() const;
  private:
  int _internal_programs_size() const;
  public:
  void clear_programs();
  ::pb::Program* mutable_programs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::Program >*
      mutable_programs();
  private:
  const ::pb::Program& _internal_programs(int index) const;
  ::pb::Program* _internal_add_programs();
  public:
  const ::pb::Program& programs(int index) const;
  ::pb::Program* add_programs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::Program >&
      programs() const;

  // .pb.UnsignedTx unsigned_tx = 1;
  bool has_unsigned_tx() const;
  private:
  bool _internal_has_unsigned_tx() const;
  public:
  void clear_unsigned_tx();
  const ::pb::UnsignedTx& unsigned_tx() const;
  PROTOBUF_MUST_USE_RESULT ::pb::UnsignedTx* release_unsigned_tx();
  ::pb::UnsignedTx* mutable_unsigned_tx();
  void set_allocated_unsigned_tx(::pb::UnsignedTx* unsigned_tx);
  private:
  const ::pb::UnsignedTx& _internal_unsigned_tx() const;
  ::pb::UnsignedTx* _internal_mutable_unsigned_tx();
  public:
  void unsafe_arena_set_allocated_unsigned_tx(
      ::pb::UnsignedTx* unsigned_tx);
  ::pb::UnsignedTx* unsafe_arena_release_unsigned_tx();

  // @@protoc_insertion_point(class_scope:pb.Transaction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::Program > programs_;
  ::pb::UnsignedTx* unsigned_tx_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pb_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class Program final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.Program) */ {
 public:
  inline Program() : Program(nullptr) {}
  ~Program() override;
  explicit constexpr Program(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Program(const Program& from);
  Program(Program&& from) noexcept
    : Program() {
    *this = ::std::move(from);
  }

  inline Program& operator=(const Program& from) {
    CopyFrom(from);
    return *this;
  }
  inline Program& operator=(Program&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Program& default_instance() {
    return *internal_default_instance();
  }
  static inline const Program* internal_default_instance() {
    return reinterpret_cast<const Program*>(
               &_Program_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Program& a, Program& b) {
    a.Swap(&b);
  }
  inline void Swap(Program* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Program* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Program* New() const final {
    return new Program();
  }

  Program* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Program>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Program& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Program& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Program* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.Program";
  }
  protected:
  explicit Program(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCodeFieldNumber = 1,
    kParameterFieldNumber = 2,
  };
  // bytes code = 1;
  void clear_code();
  const std::string& code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_code();
  PROTOBUF_MUST_USE_RESULT std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // bytes parameter = 2;
  void clear_parameter();
  const std::string& parameter() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parameter(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parameter();
  PROTOBUF_MUST_USE_RESULT std::string* release_parameter();
  void set_allocated_parameter(std::string* parameter);
  private:
  const std::string& _internal_parameter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parameter(const std::string& value);
  std::string* _internal_mutable_parameter();
  public:

  // @@protoc_insertion_point(class_scope:pb.Program)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parameter_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pb_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class Payload final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.Payload) */ {
 public:
  inline Payload() : Payload(nullptr) {}
  ~Payload() override;
  explicit constexpr Payload(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Payload(const Payload& from);
  Payload(Payload&& from) noexcept
    : Payload() {
    *this = ::std::move(from);
  }

  inline Payload& operator=(const Payload& from) {
    CopyFrom(from);
    return *this;
  }
  inline Payload& operator=(Payload&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Payload& default_instance() {
    return *internal_default_instance();
  }
  static inline const Payload* internal_default_instance() {
    return reinterpret_cast<const Payload*>(
               &_Payload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Payload& a, Payload& b) {
    a.Swap(&b);
  }
  inline void Swap(Payload* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Payload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Payload* New() const final {
    return new Payload();
  }

  Payload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Payload>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Payload& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Payload& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Payload* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.Payload";
  }
  protected:
  explicit Payload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .pb.PayloadType type = 1;
  void clear_type();
  ::pb::PayloadType type() const;
  void set_type(::pb::PayloadType value);
  private:
  ::pb::PayloadType _internal_type() const;
  void _internal_set_type(::pb::PayloadType value);
  public:

  // @@protoc_insertion_point(class_scope:pb.Payload)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pb_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class Coinbase final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.Coinbase) */ {
 public:
  inline Coinbase() : Coinbase(nullptr) {}
  ~Coinbase() override;
  explicit constexpr Coinbase(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Coinbase(const Coinbase& from);
  Coinbase(Coinbase&& from) noexcept
    : Coinbase() {
    *this = ::std::move(from);
  }

  inline Coinbase& operator=(const Coinbase& from) {
    CopyFrom(from);
    return *this;
  }
  inline Coinbase& operator=(Coinbase&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Coinbase& default_instance() {
    return *internal_default_instance();
  }
  static inline const Coinbase* internal_default_instance() {
    return reinterpret_cast<const Coinbase*>(
               &_Coinbase_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Coinbase& a, Coinbase& b) {
    a.Swap(&b);
  }
  inline void Swap(Coinbase* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Coinbase* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Coinbase* New() const final {
    return new Coinbase();
  }

  Coinbase* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Coinbase>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Coinbase& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Coinbase& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Coinbase* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.Coinbase";
  }
  protected:
  explicit Coinbase(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kRecipientFieldNumber = 2,
    kAmountFieldNumber = 3,
  };
  // bytes sender = 1;
  void clear_sender();
  const std::string& sender() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sender(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sender();
  PROTOBUF_MUST_USE_RESULT std::string* release_sender();
  void set_allocated_sender(std::string* sender);
  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(const std::string& value);
  std::string* _internal_mutable_sender();
  public:

  // bytes recipient = 2;
  void clear_recipient();
  const std::string& recipient() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_recipient(ArgT0&& arg0, ArgT... args);
  std::string* mutable_recipient();
  PROTOBUF_MUST_USE_RESULT std::string* release_recipient();
  void set_allocated_recipient(std::string* recipient);
  private:
  const std::string& _internal_recipient() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recipient(const std::string& value);
  std::string* _internal_mutable_recipient();
  public:

  // int64 amount = 3;
  void clear_amount();
  ::PROTOBUF_NAMESPACE_ID::int64 amount() const;
  void set_amount(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_amount() const;
  void _internal_set_amount(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:pb.Coinbase)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr recipient_;
  ::PROTOBUF_NAMESPACE_ID::int64 amount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pb_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class SigChainTxn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.SigChainTxn) */ {
 public:
  inline SigChainTxn() : SigChainTxn(nullptr) {}
  ~SigChainTxn() override;
  explicit constexpr SigChainTxn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SigChainTxn(const SigChainTxn& from);
  SigChainTxn(SigChainTxn&& from) noexcept
    : SigChainTxn() {
    *this = ::std::move(from);
  }

  inline SigChainTxn& operator=(const SigChainTxn& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigChainTxn& operator=(SigChainTxn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigChainTxn& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigChainTxn* internal_default_instance() {
    return reinterpret_cast<const SigChainTxn*>(
               &_SigChainTxn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SigChainTxn& a, SigChainTxn& b) {
    a.Swap(&b);
  }
  inline void Swap(SigChainTxn* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigChainTxn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SigChainTxn* New() const final {
    return new SigChainTxn();
  }

  SigChainTxn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SigChainTxn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SigChainTxn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SigChainTxn& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigChainTxn* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.SigChainTxn";
  }
  protected:
  explicit SigChainTxn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSigChainFieldNumber = 1,
    kSubmitterFieldNumber = 2,
  };
  // bytes sig_chain = 1;
  void clear_sig_chain();
  const std::string& sig_chain() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sig_chain(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sig_chain();
  PROTOBUF_MUST_USE_RESULT std::string* release_sig_chain();
  void set_allocated_sig_chain(std::string* sig_chain);
  private:
  const std::string& _internal_sig_chain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sig_chain(const std::string& value);
  std::string* _internal_mutable_sig_chain();
  public:

  // bytes submitter = 2;
  void clear_submitter();
  const std::string& submitter() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_submitter(ArgT0&& arg0, ArgT... args);
  std::string* mutable_submitter();
  PROTOBUF_MUST_USE_RESULT std::string* release_submitter();
  void set_allocated_submitter(std::string* submitter);
  private:
  const std::string& _internal_submitter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_submitter(const std::string& value);
  std::string* _internal_mutable_submitter();
  public:

  // @@protoc_insertion_point(class_scope:pb.SigChainTxn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sig_chain_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr submitter_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pb_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class RegisterName final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.RegisterName) */ {
 public:
  inline RegisterName() : RegisterName(nullptr) {}
  ~RegisterName() override;
  explicit constexpr RegisterName(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterName(const RegisterName& from);
  RegisterName(RegisterName&& from) noexcept
    : RegisterName() {
    *this = ::std::move(from);
  }

  inline RegisterName& operator=(const RegisterName& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterName& operator=(RegisterName&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterName& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterName* internal_default_instance() {
    return reinterpret_cast<const RegisterName*>(
               &_RegisterName_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RegisterName& a, RegisterName& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterName* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterName* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegisterName* New() const final {
    return new RegisterName();
  }

  RegisterName* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegisterName>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterName& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RegisterName& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterName* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.RegisterName";
  }
  protected:
  explicit RegisterName(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegistrantFieldNumber = 1,
    kNameFieldNumber = 2,
    kRegistrationFeeFieldNumber = 3,
  };
  // bytes registrant = 1;
  void clear_registrant();
  const std::string& registrant() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_registrant(ArgT0&& arg0, ArgT... args);
  std::string* mutable_registrant();
  PROTOBUF_MUST_USE_RESULT std::string* release_registrant();
  void set_allocated_registrant(std::string* registrant);
  private:
  const std::string& _internal_registrant() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_registrant(const std::string& value);
  std::string* _internal_mutable_registrant();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int64 registration_fee = 3;
  void clear_registration_fee();
  ::PROTOBUF_NAMESPACE_ID::int64 registration_fee() const;
  void set_registration_fee(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_registration_fee() const;
  void _internal_set_registration_fee(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:pb.RegisterName)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr registrant_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int64 registration_fee_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pb_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class TransferName final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.TransferName) */ {
 public:
  inline TransferName() : TransferName(nullptr) {}
  ~TransferName() override;
  explicit constexpr TransferName(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransferName(const TransferName& from);
  TransferName(TransferName&& from) noexcept
    : TransferName() {
    *this = ::std::move(from);
  }

  inline TransferName& operator=(const TransferName& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransferName& operator=(TransferName&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransferName& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransferName* internal_default_instance() {
    return reinterpret_cast<const TransferName*>(
               &_TransferName_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TransferName& a, TransferName& b) {
    a.Swap(&b);
  }
  inline void Swap(TransferName* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransferName* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TransferName* New() const final {
    return new TransferName();
  }

  TransferName* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransferName>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransferName& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransferName& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransferName* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.TransferName";
  }
  protected:
  explicit TransferName(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kRegistrantFieldNumber = 2,
    kRecipientFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bytes registrant = 2;
  void clear_registrant();
  const std::string& registrant() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_registrant(ArgT0&& arg0, ArgT... args);
  std::string* mutable_registrant();
  PROTOBUF_MUST_USE_RESULT std::string* release_registrant();
  void set_allocated_registrant(std::string* registrant);
  private:
  const std::string& _internal_registrant() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_registrant(const std::string& value);
  std::string* _internal_mutable_registrant();
  public:

  // bytes recipient = 3;
  void clear_recipient();
  const std::string& recipient() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_recipient(ArgT0&& arg0, ArgT... args);
  std::string* mutable_recipient();
  PROTOBUF_MUST_USE_RESULT std::string* release_recipient();
  void set_allocated_recipient(std::string* recipient);
  private:
  const std::string& _internal_recipient() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recipient(const std::string& value);
  std::string* _internal_mutable_recipient();
  public:

  // @@protoc_insertion_point(class_scope:pb.TransferName)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr registrant_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr recipient_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pb_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class DeleteName final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.DeleteName) */ {
 public:
  inline DeleteName() : DeleteName(nullptr) {}
  ~DeleteName() override;
  explicit constexpr DeleteName(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteName(const DeleteName& from);
  DeleteName(DeleteName&& from) noexcept
    : DeleteName() {
    *this = ::std::move(from);
  }

  inline DeleteName& operator=(const DeleteName& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteName& operator=(DeleteName&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteName& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteName* internal_default_instance() {
    return reinterpret_cast<const DeleteName*>(
               &_DeleteName_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DeleteName& a, DeleteName& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteName* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteName* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteName* New() const final {
    return new DeleteName();
  }

  DeleteName* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteName>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteName& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteName& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteName* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.DeleteName";
  }
  protected:
  explicit DeleteName(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegistrantFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // bytes registrant = 1;
  void clear_registrant();
  const std::string& registrant() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_registrant(ArgT0&& arg0, ArgT... args);
  std::string* mutable_registrant();
  PROTOBUF_MUST_USE_RESULT std::string* release_registrant();
  void set_allocated_registrant(std::string* registrant);
  private:
  const std::string& _internal_registrant() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_registrant(const std::string& value);
  std::string* _internal_mutable_registrant();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:pb.DeleteName)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr registrant_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pb_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class Subscribe final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.Subscribe) */ {
 public:
  inline Subscribe() : Subscribe(nullptr) {}
  ~Subscribe() override;
  explicit constexpr Subscribe(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Subscribe(const Subscribe& from);
  Subscribe(Subscribe&& from) noexcept
    : Subscribe() {
    *this = ::std::move(from);
  }

  inline Subscribe& operator=(const Subscribe& from) {
    CopyFrom(from);
    return *this;
  }
  inline Subscribe& operator=(Subscribe&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Subscribe& default_instance() {
    return *internal_default_instance();
  }
  static inline const Subscribe* internal_default_instance() {
    return reinterpret_cast<const Subscribe*>(
               &_Subscribe_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Subscribe& a, Subscribe& b) {
    a.Swap(&b);
  }
  inline void Swap(Subscribe* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Subscribe* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Subscribe* New() const final {
    return new Subscribe();
  }

  Subscribe* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Subscribe>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Subscribe& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Subscribe& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Subscribe* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.Subscribe";
  }
  protected:
  explicit Subscribe(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubscriberFieldNumber = 1,
    kIdentifierFieldNumber = 2,
    kTopicFieldNumber = 3,
    kMetaFieldNumber = 6,
    kBucketFieldNumber = 4,
    kDurationFieldNumber = 5,
  };
  // bytes subscriber = 1;
  void clear_subscriber();
  const std::string& subscriber() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subscriber(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subscriber();
  PROTOBUF_MUST_USE_RESULT std::string* release_subscriber();
  void set_allocated_subscriber(std::string* subscriber);
  private:
  const std::string& _internal_subscriber() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subscriber(const std::string& value);
  std::string* _internal_mutable_subscriber();
  public:

  // string identifier = 2;
  void clear_identifier();
  const std::string& identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identifier();
  PROTOBUF_MUST_USE_RESULT std::string* release_identifier();
  void set_allocated_identifier(std::string* identifier);
  private:
  const std::string& _internal_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identifier(const std::string& value);
  std::string* _internal_mutable_identifier();
  public:

  // string topic = 3;
  void clear_topic();
  const std::string& topic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_topic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_topic();
  PROTOBUF_MUST_USE_RESULT std::string* release_topic();
  void set_allocated_topic(std::string* topic);
  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(const std::string& value);
  std::string* _internal_mutable_topic();
  public:

  // bytes meta = 6;
  void clear_meta();
  const std::string& meta() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_meta(ArgT0&& arg0, ArgT... args);
  std::string* mutable_meta();
  PROTOBUF_MUST_USE_RESULT std::string* release_meta();
  void set_allocated_meta(std::string* meta);
  private:
  const std::string& _internal_meta() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_meta(const std::string& value);
  std::string* _internal_mutable_meta();
  public:

  // uint32 bucket = 4 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_bucket();
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::uint32 bucket() const;
  PROTOBUF_DEPRECATED void set_bucket(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_bucket() const;
  void _internal_set_bucket(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 duration = 5;
  void clear_duration();
  ::PROTOBUF_NAMESPACE_ID::uint32 duration() const;
  void set_duration(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_duration() const;
  void _internal_set_duration(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:pb.Subscribe)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subscriber_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr meta_;
  ::PROTOBUF_NAMESPACE_ID::uint32 bucket_;
  ::PROTOBUF_NAMESPACE_ID::uint32 duration_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pb_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class Unsubscribe final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.Unsubscribe) */ {
 public:
  inline Unsubscribe() : Unsubscribe(nullptr) {}
  ~Unsubscribe() override;
  explicit constexpr Unsubscribe(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Unsubscribe(const Unsubscribe& from);
  Unsubscribe(Unsubscribe&& from) noexcept
    : Unsubscribe() {
    *this = ::std::move(from);
  }

  inline Unsubscribe& operator=(const Unsubscribe& from) {
    CopyFrom(from);
    return *this;
  }
  inline Unsubscribe& operator=(Unsubscribe&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Unsubscribe& default_instance() {
    return *internal_default_instance();
  }
  static inline const Unsubscribe* internal_default_instance() {
    return reinterpret_cast<const Unsubscribe*>(
               &_Unsubscribe_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Unsubscribe& a, Unsubscribe& b) {
    a.Swap(&b);
  }
  inline void Swap(Unsubscribe* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Unsubscribe* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Unsubscribe* New() const final {
    return new Unsubscribe();
  }

  Unsubscribe* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Unsubscribe>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Unsubscribe& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Unsubscribe& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Unsubscribe* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.Unsubscribe";
  }
  protected:
  explicit Unsubscribe(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubscriberFieldNumber = 1,
    kIdentifierFieldNumber = 2,
    kTopicFieldNumber = 3,
  };
  // bytes subscriber = 1;
  void clear_subscriber();
  const std::string& subscriber() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subscriber(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subscriber();
  PROTOBUF_MUST_USE_RESULT std::string* release_subscriber();
  void set_allocated_subscriber(std::string* subscriber);
  private:
  const std::string& _internal_subscriber() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subscriber(const std::string& value);
  std::string* _internal_mutable_subscriber();
  public:

  // string identifier = 2;
  void clear_identifier();
  const std::string& identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identifier();
  PROTOBUF_MUST_USE_RESULT std::string* release_identifier();
  void set_allocated_identifier(std::string* identifier);
  private:
  const std::string& _internal_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identifier(const std::string& value);
  std::string* _internal_mutable_identifier();
  public:

  // string topic = 3;
  void clear_topic();
  const std::string& topic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_topic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_topic();
  PROTOBUF_MUST_USE_RESULT std::string* release_topic();
  void set_allocated_topic(std::string* topic);
  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(const std::string& value);
  std::string* _internal_mutable_topic();
  public:

  // @@protoc_insertion_point(class_scope:pb.Unsubscribe)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subscriber_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pb_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class TransferAsset final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.TransferAsset) */ {
 public:
  inline TransferAsset() : TransferAsset(nullptr) {}
  ~TransferAsset() override;
  explicit constexpr TransferAsset(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransferAsset(const TransferAsset& from);
  TransferAsset(TransferAsset&& from) noexcept
    : TransferAsset() {
    *this = ::std::move(from);
  }

  inline TransferAsset& operator=(const TransferAsset& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransferAsset& operator=(TransferAsset&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransferAsset& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransferAsset* internal_default_instance() {
    return reinterpret_cast<const TransferAsset*>(
               &_TransferAsset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(TransferAsset& a, TransferAsset& b) {
    a.Swap(&b);
  }
  inline void Swap(TransferAsset* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransferAsset* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TransferAsset* New() const final {
    return new TransferAsset();
  }

  TransferAsset* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransferAsset>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransferAsset& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransferAsset& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransferAsset* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.TransferAsset";
  }
  protected:
  explicit TransferAsset(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kRecipientFieldNumber = 2,
    kAmountFieldNumber = 3,
  };
  // bytes sender = 1;
  void clear_sender();
  const std::string& sender() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sender(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sender();
  PROTOBUF_MUST_USE_RESULT std::string* release_sender();
  void set_allocated_sender(std::string* sender);
  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(const std::string& value);
  std::string* _internal_mutable_sender();
  public:

  // bytes recipient = 2;
  void clear_recipient();
  const std::string& recipient() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_recipient(ArgT0&& arg0, ArgT... args);
  std::string* mutable_recipient();
  PROTOBUF_MUST_USE_RESULT std::string* release_recipient();
  void set_allocated_recipient(std::string* recipient);
  private:
  const std::string& _internal_recipient() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recipient(const std::string& value);
  std::string* _internal_mutable_recipient();
  public:

  // int64 amount = 3;
  void clear_amount();
  ::PROTOBUF_NAMESPACE_ID::int64 amount() const;
  void set_amount(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_amount() const;
  void _internal_set_amount(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:pb.TransferAsset)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr recipient_;
  ::PROTOBUF_NAMESPACE_ID::int64 amount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pb_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class GenerateID final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.GenerateID) */ {
 public:
  inline GenerateID() : GenerateID(nullptr) {}
  ~GenerateID() override;
  explicit constexpr GenerateID(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GenerateID(const GenerateID& from);
  GenerateID(GenerateID&& from) noexcept
    : GenerateID() {
    *this = ::std::move(from);
  }

  inline GenerateID& operator=(const GenerateID& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenerateID& operator=(GenerateID&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenerateID& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenerateID* internal_default_instance() {
    return reinterpret_cast<const GenerateID*>(
               &_GenerateID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GenerateID& a, GenerateID& b) {
    a.Swap(&b);
  }
  inline void Swap(GenerateID* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenerateID* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GenerateID* New() const final {
    return new GenerateID();
  }

  GenerateID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GenerateID>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GenerateID& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GenerateID& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenerateID* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.GenerateID";
  }
  protected:
  explicit GenerateID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicKeyFieldNumber = 1,
    kSenderFieldNumber = 3,
    kRegistrationFeeFieldNumber = 2,
    kVersionFieldNumber = 4,
  };
  // bytes public_key = 1;
  void clear_public_key();
  const std::string& public_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_public_key();
  void set_allocated_public_key(std::string* public_key);
  private:
  const std::string& _internal_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key(const std::string& value);
  std::string* _internal_mutable_public_key();
  public:

  // bytes sender = 3;
  void clear_sender();
  const std::string& sender() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sender(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sender();
  PROTOBUF_MUST_USE_RESULT std::string* release_sender();
  void set_allocated_sender(std::string* sender);
  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(const std::string& value);
  std::string* _internal_mutable_sender();
  public:

  // int64 registration_fee = 2;
  void clear_registration_fee();
  ::PROTOBUF_NAMESPACE_ID::int64 registration_fee() const;
  void set_registration_fee(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_registration_fee() const;
  void _internal_set_registration_fee(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int32 version = 4;
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::int32 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_version() const;
  void _internal_set_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:pb.GenerateID)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
  ::PROTOBUF_NAMESPACE_ID::int64 registration_fee_;
  ::PROTOBUF_NAMESPACE_ID::int32 version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pb_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class NanoPay final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.NanoPay) */ {
 public:
  inline NanoPay() : NanoPay(nullptr) {}
  ~NanoPay() override;
  explicit constexpr NanoPay(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NanoPay(const NanoPay& from);
  NanoPay(NanoPay&& from) noexcept
    : NanoPay() {
    *this = ::std::move(from);
  }

  inline NanoPay& operator=(const NanoPay& from) {
    CopyFrom(from);
    return *this;
  }
  inline NanoPay& operator=(NanoPay&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NanoPay& default_instance() {
    return *internal_default_instance();
  }
  static inline const NanoPay* internal_default_instance() {
    return reinterpret_cast<const NanoPay*>(
               &_NanoPay_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(NanoPay& a, NanoPay& b) {
    a.Swap(&b);
  }
  inline void Swap(NanoPay* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NanoPay* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NanoPay* New() const final {
    return new NanoPay();
  }

  NanoPay* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NanoPay>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NanoPay& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NanoPay& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NanoPay* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.NanoPay";
  }
  protected:
  explicit NanoPay(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kRecipientFieldNumber = 2,
    kIdFieldNumber = 3,
    kAmountFieldNumber = 4,
    kTxnExpirationFieldNumber = 5,
    kNanoPayExpirationFieldNumber = 6,
  };
  // bytes sender = 1;
  void clear_sender();
  const std::string& sender() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sender(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sender();
  PROTOBUF_MUST_USE_RESULT std::string* release_sender();
  void set_allocated_sender(std::string* sender);
  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(const std::string& value);
  std::string* _internal_mutable_sender();
  public:

  // bytes recipient = 2;
  void clear_recipient();
  const std::string& recipient() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_recipient(ArgT0&& arg0, ArgT... args);
  std::string* mutable_recipient();
  PROTOBUF_MUST_USE_RESULT std::string* release_recipient();
  void set_allocated_recipient(std::string* recipient);
  private:
  const std::string& _internal_recipient() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recipient(const std::string& value);
  std::string* _internal_mutable_recipient();
  public:

  // uint64 id = 3;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // int64 amount = 4;
  void clear_amount();
  ::PROTOBUF_NAMESPACE_ID::int64 amount() const;
  void set_amount(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_amount() const;
  void _internal_set_amount(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // uint32 txn_expiration = 5;
  void clear_txn_expiration();
  ::PROTOBUF_NAMESPACE_ID::uint32 txn_expiration() const;
  void set_txn_expiration(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_txn_expiration() const;
  void _internal_set_txn_expiration(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 nano_pay_expiration = 6;
  void clear_nano_pay_expiration();
  ::PROTOBUF_NAMESPACE_ID::uint32 nano_pay_expiration() const;
  void set_nano_pay_expiration(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_nano_pay_expiration() const;
  void _internal_set_nano_pay_expiration(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:pb.NanoPay)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr recipient_;
  ::PROTOBUF_NAMESPACE_ID::uint64 id_;
  ::PROTOBUF_NAMESPACE_ID::int64 amount_;
  ::PROTOBUF_NAMESPACE_ID::uint32 txn_expiration_;
  ::PROTOBUF_NAMESPACE_ID::uint32 nano_pay_expiration_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pb_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class IssueAsset final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.IssueAsset) */ {
 public:
  inline IssueAsset() : IssueAsset(nullptr) {}
  ~IssueAsset() override;
  explicit constexpr IssueAsset(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IssueAsset(const IssueAsset& from);
  IssueAsset(IssueAsset&& from) noexcept
    : IssueAsset() {
    *this = ::std::move(from);
  }

  inline IssueAsset& operator=(const IssueAsset& from) {
    CopyFrom(from);
    return *this;
  }
  inline IssueAsset& operator=(IssueAsset&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IssueAsset& default_instance() {
    return *internal_default_instance();
  }
  static inline const IssueAsset* internal_default_instance() {
    return reinterpret_cast<const IssueAsset*>(
               &_IssueAsset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(IssueAsset& a, IssueAsset& b) {
    a.Swap(&b);
  }
  inline void Swap(IssueAsset* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IssueAsset* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IssueAsset* New() const final {
    return new IssueAsset();
  }

  IssueAsset* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IssueAsset>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IssueAsset& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IssueAsset& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IssueAsset* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.IssueAsset";
  }
  protected:
  explicit IssueAsset(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kNameFieldNumber = 2,
    kSymbolFieldNumber = 3,
    kTotalSupplyFieldNumber = 4,
    kPrecisionFieldNumber = 5,
  };
  // bytes sender = 1;
  void clear_sender();
  const std::string& sender() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sender(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sender();
  PROTOBUF_MUST_USE_RESULT std::string* release_sender();
  void set_allocated_sender(std::string* sender);
  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(const std::string& value);
  std::string* _internal_mutable_sender();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string symbol = 3;
  void clear_symbol();
  const std::string& symbol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_symbol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_symbol();
  PROTOBUF_MUST_USE_RESULT std::string* release_symbol();
  void set_allocated_symbol(std::string* symbol);
  private:
  const std::string& _internal_symbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_symbol(const std::string& value);
  std::string* _internal_mutable_symbol();
  public:

  // int64 total_supply = 4;
  void clear_total_supply();
  ::PROTOBUF_NAMESPACE_ID::int64 total_supply() const;
  void set_total_supply(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_total_supply() const;
  void _internal_set_total_supply(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // uint32 precision = 5;
  void clear_precision();
  ::PROTOBUF_NAMESPACE_ID::uint32 precision() const;
  void set_precision(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_precision() const;
  void _internal_set_precision(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:pb.IssueAsset)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr symbol_;
  ::PROTOBUF_NAMESPACE_ID::int64 total_supply_;
  ::PROTOBUF_NAMESPACE_ID::uint32 precision_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pb_2ftransaction_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// UnsignedTx

// .pb.Payload payload = 1;
inline bool UnsignedTx::_internal_has_payload() const {
  return this != internal_default_instance() && payload_ != nullptr;
}
inline bool UnsignedTx::has_payload() const {
  return _internal_has_payload();
}
inline void UnsignedTx::clear_payload() {
  if (GetArenaForAllocation() == nullptr && payload_ != nullptr) {
    delete payload_;
  }
  payload_ = nullptr;
}
inline const ::pb::Payload& UnsignedTx::_internal_payload() const {
  const ::pb::Payload* p = payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::Payload&>(
      ::pb::_Payload_default_instance_);
}
inline const ::pb::Payload& UnsignedTx::payload() const {
  // @@protoc_insertion_point(field_get:pb.UnsignedTx.payload)
  return _internal_payload();
}
inline void UnsignedTx::unsafe_arena_set_allocated_payload(
    ::pb::Payload* payload) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payload_);
  }
  payload_ = payload;
  if (payload) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.UnsignedTx.payload)
}
inline ::pb::Payload* UnsignedTx::release_payload() {
  
  ::pb::Payload* temp = payload_;
  payload_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::Payload* UnsignedTx::unsafe_arena_release_payload() {
  // @@protoc_insertion_point(field_release:pb.UnsignedTx.payload)
  
  ::pb::Payload* temp = payload_;
  payload_ = nullptr;
  return temp;
}
inline ::pb::Payload* UnsignedTx::_internal_mutable_payload() {
  
  if (payload_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::Payload>(GetArenaForAllocation());
    payload_ = p;
  }
  return payload_;
}
inline ::pb::Payload* UnsignedTx::mutable_payload() {
  ::pb::Payload* _msg = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:pb.UnsignedTx.payload)
  return _msg;
}
inline void UnsignedTx::set_allocated_payload(::pb::Payload* payload) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete payload_;
  }
  if (payload) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pb::Payload>::GetOwningArena(payload);
    if (message_arena != submessage_arena) {
      payload = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payload, submessage_arena);
    }
    
  } else {
    
  }
  payload_ = payload;
  // @@protoc_insertion_point(field_set_allocated:pb.UnsignedTx.payload)
}

// uint64 nonce = 2;
inline void UnsignedTx::clear_nonce() {
  nonce_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 UnsignedTx::_internal_nonce() const {
  return nonce_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 UnsignedTx::nonce() const {
  // @@protoc_insertion_point(field_get:pb.UnsignedTx.nonce)
  return _internal_nonce();
}
inline void UnsignedTx::_internal_set_nonce(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  nonce_ = value;
}
inline void UnsignedTx::set_nonce(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:pb.UnsignedTx.nonce)
}

// int64 fee = 3;
inline void UnsignedTx::clear_fee() {
  fee_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 UnsignedTx::_internal_fee() const {
  return fee_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 UnsignedTx::fee() const {
  // @@protoc_insertion_point(field_get:pb.UnsignedTx.fee)
  return _internal_fee();
}
inline void UnsignedTx::_internal_set_fee(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  fee_ = value;
}
inline void UnsignedTx::set_fee(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_fee(value);
  // @@protoc_insertion_point(field_set:pb.UnsignedTx.fee)
}

// bytes attributes = 4;
inline void UnsignedTx::clear_attributes() {
  attributes_.ClearToEmpty();
}
inline const std::string& UnsignedTx::attributes() const {
  // @@protoc_insertion_point(field_get:pb.UnsignedTx.attributes)
  return _internal_attributes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnsignedTx::set_attributes(ArgT0&& arg0, ArgT... args) {
 
 attributes_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.UnsignedTx.attributes)
}
inline std::string* UnsignedTx::mutable_attributes() {
  std::string* _s = _internal_mutable_attributes();
  // @@protoc_insertion_point(field_mutable:pb.UnsignedTx.attributes)
  return _s;
}
inline const std::string& UnsignedTx::_internal_attributes() const {
  return attributes_.Get();
}
inline void UnsignedTx::_internal_set_attributes(const std::string& value) {
  
  attributes_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UnsignedTx::_internal_mutable_attributes() {
  
  return attributes_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UnsignedTx::release_attributes() {
  // @@protoc_insertion_point(field_release:pb.UnsignedTx.attributes)
  return attributes_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UnsignedTx::set_allocated_attributes(std::string* attributes) {
  if (attributes != nullptr) {
    
  } else {
    
  }
  attributes_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), attributes,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pb.UnsignedTx.attributes)
}

// -------------------------------------------------------------------

// Transaction

// .pb.UnsignedTx unsigned_tx = 1;
inline bool Transaction::_internal_has_unsigned_tx() const {
  return this != internal_default_instance() && unsigned_tx_ != nullptr;
}
inline bool Transaction::has_unsigned_tx() const {
  return _internal_has_unsigned_tx();
}
inline void Transaction::clear_unsigned_tx() {
  if (GetArenaForAllocation() == nullptr && unsigned_tx_ != nullptr) {
    delete unsigned_tx_;
  }
  unsigned_tx_ = nullptr;
}
inline const ::pb::UnsignedTx& Transaction::_internal_unsigned_tx() const {
  const ::pb::UnsignedTx* p = unsigned_tx_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::UnsignedTx&>(
      ::pb::_UnsignedTx_default_instance_);
}
inline const ::pb::UnsignedTx& Transaction::unsigned_tx() const {
  // @@protoc_insertion_point(field_get:pb.Transaction.unsigned_tx)
  return _internal_unsigned_tx();
}
inline void Transaction::unsafe_arena_set_allocated_unsigned_tx(
    ::pb::UnsignedTx* unsigned_tx) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(unsigned_tx_);
  }
  unsigned_tx_ = unsigned_tx;
  if (unsigned_tx) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.Transaction.unsigned_tx)
}
inline ::pb::UnsignedTx* Transaction::release_unsigned_tx() {
  
  ::pb::UnsignedTx* temp = unsigned_tx_;
  unsigned_tx_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::UnsignedTx* Transaction::unsafe_arena_release_unsigned_tx() {
  // @@protoc_insertion_point(field_release:pb.Transaction.unsigned_tx)
  
  ::pb::UnsignedTx* temp = unsigned_tx_;
  unsigned_tx_ = nullptr;
  return temp;
}
inline ::pb::UnsignedTx* Transaction::_internal_mutable_unsigned_tx() {
  
  if (unsigned_tx_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::UnsignedTx>(GetArenaForAllocation());
    unsigned_tx_ = p;
  }
  return unsigned_tx_;
}
inline ::pb::UnsignedTx* Transaction::mutable_unsigned_tx() {
  ::pb::UnsignedTx* _msg = _internal_mutable_unsigned_tx();
  // @@protoc_insertion_point(field_mutable:pb.Transaction.unsigned_tx)
  return _msg;
}
inline void Transaction::set_allocated_unsigned_tx(::pb::UnsignedTx* unsigned_tx) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete unsigned_tx_;
  }
  if (unsigned_tx) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pb::UnsignedTx>::GetOwningArena(unsigned_tx);
    if (message_arena != submessage_arena) {
      unsigned_tx = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unsigned_tx, submessage_arena);
    }
    
  } else {
    
  }
  unsigned_tx_ = unsigned_tx;
  // @@protoc_insertion_point(field_set_allocated:pb.Transaction.unsigned_tx)
}

// repeated .pb.Program programs = 2;
inline int Transaction::_internal_programs_size() const {
  return programs_.size();
}
inline int Transaction::programs_size() const {
  return _internal_programs_size();
}
inline void Transaction::clear_programs() {
  programs_.Clear();
}
inline ::pb::Program* Transaction::mutable_programs(int index) {
  // @@protoc_insertion_point(field_mutable:pb.Transaction.programs)
  return programs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::Program >*
Transaction::mutable_programs() {
  // @@protoc_insertion_point(field_mutable_list:pb.Transaction.programs)
  return &programs_;
}
inline const ::pb::Program& Transaction::_internal_programs(int index) const {
  return programs_.Get(index);
}
inline const ::pb::Program& Transaction::programs(int index) const {
  // @@protoc_insertion_point(field_get:pb.Transaction.programs)
  return _internal_programs(index);
}
inline ::pb::Program* Transaction::_internal_add_programs() {
  return programs_.Add();
}
inline ::pb::Program* Transaction::add_programs() {
  ::pb::Program* _add = _internal_add_programs();
  // @@protoc_insertion_point(field_add:pb.Transaction.programs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::Program >&
Transaction::programs() const {
  // @@protoc_insertion_point(field_list:pb.Transaction.programs)
  return programs_;
}

// -------------------------------------------------------------------

// Program

// bytes code = 1;
inline void Program::clear_code() {
  code_.ClearToEmpty();
}
inline const std::string& Program::code() const {
  // @@protoc_insertion_point(field_get:pb.Program.code)
  return _internal_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Program::set_code(ArgT0&& arg0, ArgT... args) {
 
 code_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.Program.code)
}
inline std::string* Program::mutable_code() {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:pb.Program.code)
  return _s;
}
inline const std::string& Program::_internal_code() const {
  return code_.Get();
}
inline void Program::_internal_set_code(const std::string& value) {
  
  code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Program::_internal_mutable_code() {
  
  return code_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Program::release_code() {
  // @@protoc_insertion_point(field_release:pb.Program.code)
  return code_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Program::set_allocated_code(std::string* code) {
  if (code != nullptr) {
    
  } else {
    
  }
  code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), code,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pb.Program.code)
}

// bytes parameter = 2;
inline void Program::clear_parameter() {
  parameter_.ClearToEmpty();
}
inline const std::string& Program::parameter() const {
  // @@protoc_insertion_point(field_get:pb.Program.parameter)
  return _internal_parameter();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Program::set_parameter(ArgT0&& arg0, ArgT... args) {
 
 parameter_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.Program.parameter)
}
inline std::string* Program::mutable_parameter() {
  std::string* _s = _internal_mutable_parameter();
  // @@protoc_insertion_point(field_mutable:pb.Program.parameter)
  return _s;
}
inline const std::string& Program::_internal_parameter() const {
  return parameter_.Get();
}
inline void Program::_internal_set_parameter(const std::string& value) {
  
  parameter_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Program::_internal_mutable_parameter() {
  
  return parameter_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Program::release_parameter() {
  // @@protoc_insertion_point(field_release:pb.Program.parameter)
  return parameter_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Program::set_allocated_parameter(std::string* parameter) {
  if (parameter != nullptr) {
    
  } else {
    
  }
  parameter_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), parameter,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pb.Program.parameter)
}

// -------------------------------------------------------------------

// Payload

// .pb.PayloadType type = 1;
inline void Payload::clear_type() {
  type_ = 0;
}
inline ::pb::PayloadType Payload::_internal_type() const {
  return static_cast< ::pb::PayloadType >(type_);
}
inline ::pb::PayloadType Payload::type() const {
  // @@protoc_insertion_point(field_get:pb.Payload.type)
  return _internal_type();
}
inline void Payload::_internal_set_type(::pb::PayloadType value) {
  
  type_ = value;
}
inline void Payload::set_type(::pb::PayloadType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:pb.Payload.type)
}

// bytes data = 2;
inline void Payload::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& Payload::data() const {
  // @@protoc_insertion_point(field_get:pb.Payload.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Payload::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.Payload.data)
}
inline std::string* Payload::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:pb.Payload.data)
  return _s;
}
inline const std::string& Payload::_internal_data() const {
  return data_.Get();
}
inline void Payload::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Payload::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Payload::release_data() {
  // @@protoc_insertion_point(field_release:pb.Payload.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Payload::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pb.Payload.data)
}

// -------------------------------------------------------------------

// Coinbase

// bytes sender = 1;
inline void Coinbase::clear_sender() {
  sender_.ClearToEmpty();
}
inline const std::string& Coinbase::sender() const {
  // @@protoc_insertion_point(field_get:pb.Coinbase.sender)
  return _internal_sender();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Coinbase::set_sender(ArgT0&& arg0, ArgT... args) {
 
 sender_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.Coinbase.sender)
}
inline std::string* Coinbase::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:pb.Coinbase.sender)
  return _s;
}
inline const std::string& Coinbase::_internal_sender() const {
  return sender_.Get();
}
inline void Coinbase::_internal_set_sender(const std::string& value) {
  
  sender_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Coinbase::_internal_mutable_sender() {
  
  return sender_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Coinbase::release_sender() {
  // @@protoc_insertion_point(field_release:pb.Coinbase.sender)
  return sender_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Coinbase::set_allocated_sender(std::string* sender) {
  if (sender != nullptr) {
    
  } else {
    
  }
  sender_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sender,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pb.Coinbase.sender)
}

// bytes recipient = 2;
inline void Coinbase::clear_recipient() {
  recipient_.ClearToEmpty();
}
inline const std::string& Coinbase::recipient() const {
  // @@protoc_insertion_point(field_get:pb.Coinbase.recipient)
  return _internal_recipient();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Coinbase::set_recipient(ArgT0&& arg0, ArgT... args) {
 
 recipient_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.Coinbase.recipient)
}
inline std::string* Coinbase::mutable_recipient() {
  std::string* _s = _internal_mutable_recipient();
  // @@protoc_insertion_point(field_mutable:pb.Coinbase.recipient)
  return _s;
}
inline const std::string& Coinbase::_internal_recipient() const {
  return recipient_.Get();
}
inline void Coinbase::_internal_set_recipient(const std::string& value) {
  
  recipient_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Coinbase::_internal_mutable_recipient() {
  
  return recipient_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Coinbase::release_recipient() {
  // @@protoc_insertion_point(field_release:pb.Coinbase.recipient)
  return recipient_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Coinbase::set_allocated_recipient(std::string* recipient) {
  if (recipient != nullptr) {
    
  } else {
    
  }
  recipient_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), recipient,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pb.Coinbase.recipient)
}

// int64 amount = 3;
inline void Coinbase::clear_amount() {
  amount_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Coinbase::_internal_amount() const {
  return amount_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Coinbase::amount() const {
  // @@protoc_insertion_point(field_get:pb.Coinbase.amount)
  return _internal_amount();
}
inline void Coinbase::_internal_set_amount(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  amount_ = value;
}
inline void Coinbase::set_amount(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:pb.Coinbase.amount)
}

// -------------------------------------------------------------------

// SigChainTxn

// bytes sig_chain = 1;
inline void SigChainTxn::clear_sig_chain() {
  sig_chain_.ClearToEmpty();
}
inline const std::string& SigChainTxn::sig_chain() const {
  // @@protoc_insertion_point(field_get:pb.SigChainTxn.sig_chain)
  return _internal_sig_chain();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SigChainTxn::set_sig_chain(ArgT0&& arg0, ArgT... args) {
 
 sig_chain_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.SigChainTxn.sig_chain)
}
inline std::string* SigChainTxn::mutable_sig_chain() {
  std::string* _s = _internal_mutable_sig_chain();
  // @@protoc_insertion_point(field_mutable:pb.SigChainTxn.sig_chain)
  return _s;
}
inline const std::string& SigChainTxn::_internal_sig_chain() const {
  return sig_chain_.Get();
}
inline void SigChainTxn::_internal_set_sig_chain(const std::string& value) {
  
  sig_chain_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SigChainTxn::_internal_mutable_sig_chain() {
  
  return sig_chain_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SigChainTxn::release_sig_chain() {
  // @@protoc_insertion_point(field_release:pb.SigChainTxn.sig_chain)
  return sig_chain_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SigChainTxn::set_allocated_sig_chain(std::string* sig_chain) {
  if (sig_chain != nullptr) {
    
  } else {
    
  }
  sig_chain_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sig_chain,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pb.SigChainTxn.sig_chain)
}

// bytes submitter = 2;
inline void SigChainTxn::clear_submitter() {
  submitter_.ClearToEmpty();
}
inline const std::string& SigChainTxn::submitter() const {
  // @@protoc_insertion_point(field_get:pb.SigChainTxn.submitter)
  return _internal_submitter();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SigChainTxn::set_submitter(ArgT0&& arg0, ArgT... args) {
 
 submitter_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.SigChainTxn.submitter)
}
inline std::string* SigChainTxn::mutable_submitter() {
  std::string* _s = _internal_mutable_submitter();
  // @@protoc_insertion_point(field_mutable:pb.SigChainTxn.submitter)
  return _s;
}
inline const std::string& SigChainTxn::_internal_submitter() const {
  return submitter_.Get();
}
inline void SigChainTxn::_internal_set_submitter(const std::string& value) {
  
  submitter_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SigChainTxn::_internal_mutable_submitter() {
  
  return submitter_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SigChainTxn::release_submitter() {
  // @@protoc_insertion_point(field_release:pb.SigChainTxn.submitter)
  return submitter_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SigChainTxn::set_allocated_submitter(std::string* submitter) {
  if (submitter != nullptr) {
    
  } else {
    
  }
  submitter_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), submitter,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pb.SigChainTxn.submitter)
}

// -------------------------------------------------------------------

// RegisterName

// bytes registrant = 1;
inline void RegisterName::clear_registrant() {
  registrant_.ClearToEmpty();
}
inline const std::string& RegisterName::registrant() const {
  // @@protoc_insertion_point(field_get:pb.RegisterName.registrant)
  return _internal_registrant();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterName::set_registrant(ArgT0&& arg0, ArgT... args) {
 
 registrant_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.RegisterName.registrant)
}
inline std::string* RegisterName::mutable_registrant() {
  std::string* _s = _internal_mutable_registrant();
  // @@protoc_insertion_point(field_mutable:pb.RegisterName.registrant)
  return _s;
}
inline const std::string& RegisterName::_internal_registrant() const {
  return registrant_.Get();
}
inline void RegisterName::_internal_set_registrant(const std::string& value) {
  
  registrant_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegisterName::_internal_mutable_registrant() {
  
  return registrant_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegisterName::release_registrant() {
  // @@protoc_insertion_point(field_release:pb.RegisterName.registrant)
  return registrant_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegisterName::set_allocated_registrant(std::string* registrant) {
  if (registrant != nullptr) {
    
  } else {
    
  }
  registrant_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), registrant,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pb.RegisterName.registrant)
}

// string name = 2;
inline void RegisterName::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& RegisterName::name() const {
  // @@protoc_insertion_point(field_get:pb.RegisterName.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterName::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.RegisterName.name)
}
inline std::string* RegisterName::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:pb.RegisterName.name)
  return _s;
}
inline const std::string& RegisterName::_internal_name() const {
  return name_.Get();
}
inline void RegisterName::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegisterName::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegisterName::release_name() {
  // @@protoc_insertion_point(field_release:pb.RegisterName.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegisterName::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pb.RegisterName.name)
}

// int64 registration_fee = 3;
inline void RegisterName::clear_registration_fee() {
  registration_fee_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegisterName::_internal_registration_fee() const {
  return registration_fee_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegisterName::registration_fee() const {
  // @@protoc_insertion_point(field_get:pb.RegisterName.registration_fee)
  return _internal_registration_fee();
}
inline void RegisterName::_internal_set_registration_fee(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  registration_fee_ = value;
}
inline void RegisterName::set_registration_fee(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_registration_fee(value);
  // @@protoc_insertion_point(field_set:pb.RegisterName.registration_fee)
}

// -------------------------------------------------------------------

// TransferName

// string name = 1;
inline void TransferName::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& TransferName::name() const {
  // @@protoc_insertion_point(field_get:pb.TransferName.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransferName::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.TransferName.name)
}
inline std::string* TransferName::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:pb.TransferName.name)
  return _s;
}
inline const std::string& TransferName::_internal_name() const {
  return name_.Get();
}
inline void TransferName::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransferName::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransferName::release_name() {
  // @@protoc_insertion_point(field_release:pb.TransferName.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransferName::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pb.TransferName.name)
}

// bytes registrant = 2;
inline void TransferName::clear_registrant() {
  registrant_.ClearToEmpty();
}
inline const std::string& TransferName::registrant() const {
  // @@protoc_insertion_point(field_get:pb.TransferName.registrant)
  return _internal_registrant();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransferName::set_registrant(ArgT0&& arg0, ArgT... args) {
 
 registrant_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.TransferName.registrant)
}
inline std::string* TransferName::mutable_registrant() {
  std::string* _s = _internal_mutable_registrant();
  // @@protoc_insertion_point(field_mutable:pb.TransferName.registrant)
  return _s;
}
inline const std::string& TransferName::_internal_registrant() const {
  return registrant_.Get();
}
inline void TransferName::_internal_set_registrant(const std::string& value) {
  
  registrant_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransferName::_internal_mutable_registrant() {
  
  return registrant_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransferName::release_registrant() {
  // @@protoc_insertion_point(field_release:pb.TransferName.registrant)
  return registrant_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransferName::set_allocated_registrant(std::string* registrant) {
  if (registrant != nullptr) {
    
  } else {
    
  }
  registrant_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), registrant,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pb.TransferName.registrant)
}

// bytes recipient = 3;
inline void TransferName::clear_recipient() {
  recipient_.ClearToEmpty();
}
inline const std::string& TransferName::recipient() const {
  // @@protoc_insertion_point(field_get:pb.TransferName.recipient)
  return _internal_recipient();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransferName::set_recipient(ArgT0&& arg0, ArgT... args) {
 
 recipient_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.TransferName.recipient)
}
inline std::string* TransferName::mutable_recipient() {
  std::string* _s = _internal_mutable_recipient();
  // @@protoc_insertion_point(field_mutable:pb.TransferName.recipient)
  return _s;
}
inline const std::string& TransferName::_internal_recipient() const {
  return recipient_.Get();
}
inline void TransferName::_internal_set_recipient(const std::string& value) {
  
  recipient_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransferName::_internal_mutable_recipient() {
  
  return recipient_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransferName::release_recipient() {
  // @@protoc_insertion_point(field_release:pb.TransferName.recipient)
  return recipient_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransferName::set_allocated_recipient(std::string* recipient) {
  if (recipient != nullptr) {
    
  } else {
    
  }
  recipient_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), recipient,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pb.TransferName.recipient)
}

// -------------------------------------------------------------------

// DeleteName

// bytes registrant = 1;
inline void DeleteName::clear_registrant() {
  registrant_.ClearToEmpty();
}
inline const std::string& DeleteName::registrant() const {
  // @@protoc_insertion_point(field_get:pb.DeleteName.registrant)
  return _internal_registrant();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteName::set_registrant(ArgT0&& arg0, ArgT... args) {
 
 registrant_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.DeleteName.registrant)
}
inline std::string* DeleteName::mutable_registrant() {
  std::string* _s = _internal_mutable_registrant();
  // @@protoc_insertion_point(field_mutable:pb.DeleteName.registrant)
  return _s;
}
inline const std::string& DeleteName::_internal_registrant() const {
  return registrant_.Get();
}
inline void DeleteName::_internal_set_registrant(const std::string& value) {
  
  registrant_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteName::_internal_mutable_registrant() {
  
  return registrant_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteName::release_registrant() {
  // @@protoc_insertion_point(field_release:pb.DeleteName.registrant)
  return registrant_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteName::set_allocated_registrant(std::string* registrant) {
  if (registrant != nullptr) {
    
  } else {
    
  }
  registrant_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), registrant,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pb.DeleteName.registrant)
}

// string name = 2;
inline void DeleteName::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& DeleteName::name() const {
  // @@protoc_insertion_point(field_get:pb.DeleteName.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteName::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.DeleteName.name)
}
inline std::string* DeleteName::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:pb.DeleteName.name)
  return _s;
}
inline const std::string& DeleteName::_internal_name() const {
  return name_.Get();
}
inline void DeleteName::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteName::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteName::release_name() {
  // @@protoc_insertion_point(field_release:pb.DeleteName.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteName::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pb.DeleteName.name)
}

// -------------------------------------------------------------------

// Subscribe

// bytes subscriber = 1;
inline void Subscribe::clear_subscriber() {
  subscriber_.ClearToEmpty();
}
inline const std::string& Subscribe::subscriber() const {
  // @@protoc_insertion_point(field_get:pb.Subscribe.subscriber)
  return _internal_subscriber();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Subscribe::set_subscriber(ArgT0&& arg0, ArgT... args) {
 
 subscriber_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.Subscribe.subscriber)
}
inline std::string* Subscribe::mutable_subscriber() {
  std::string* _s = _internal_mutable_subscriber();
  // @@protoc_insertion_point(field_mutable:pb.Subscribe.subscriber)
  return _s;
}
inline const std::string& Subscribe::_internal_subscriber() const {
  return subscriber_.Get();
}
inline void Subscribe::_internal_set_subscriber(const std::string& value) {
  
  subscriber_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Subscribe::_internal_mutable_subscriber() {
  
  return subscriber_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Subscribe::release_subscriber() {
  // @@protoc_insertion_point(field_release:pb.Subscribe.subscriber)
  return subscriber_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Subscribe::set_allocated_subscriber(std::string* subscriber) {
  if (subscriber != nullptr) {
    
  } else {
    
  }
  subscriber_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), subscriber,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pb.Subscribe.subscriber)
}

// string identifier = 2;
inline void Subscribe::clear_identifier() {
  identifier_.ClearToEmpty();
}
inline const std::string& Subscribe::identifier() const {
  // @@protoc_insertion_point(field_get:pb.Subscribe.identifier)
  return _internal_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Subscribe::set_identifier(ArgT0&& arg0, ArgT... args) {
 
 identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.Subscribe.identifier)
}
inline std::string* Subscribe::mutable_identifier() {
  std::string* _s = _internal_mutable_identifier();
  // @@protoc_insertion_point(field_mutable:pb.Subscribe.identifier)
  return _s;
}
inline const std::string& Subscribe::_internal_identifier() const {
  return identifier_.Get();
}
inline void Subscribe::_internal_set_identifier(const std::string& value) {
  
  identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Subscribe::_internal_mutable_identifier() {
  
  return identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Subscribe::release_identifier() {
  // @@protoc_insertion_point(field_release:pb.Subscribe.identifier)
  return identifier_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Subscribe::set_allocated_identifier(std::string* identifier) {
  if (identifier != nullptr) {
    
  } else {
    
  }
  identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), identifier,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pb.Subscribe.identifier)
}

// string topic = 3;
inline void Subscribe::clear_topic() {
  topic_.ClearToEmpty();
}
inline const std::string& Subscribe::topic() const {
  // @@protoc_insertion_point(field_get:pb.Subscribe.topic)
  return _internal_topic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Subscribe::set_topic(ArgT0&& arg0, ArgT... args) {
 
 topic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.Subscribe.topic)
}
inline std::string* Subscribe::mutable_topic() {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:pb.Subscribe.topic)
  return _s;
}
inline const std::string& Subscribe::_internal_topic() const {
  return topic_.Get();
}
inline void Subscribe::_internal_set_topic(const std::string& value) {
  
  topic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Subscribe::_internal_mutable_topic() {
  
  return topic_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Subscribe::release_topic() {
  // @@protoc_insertion_point(field_release:pb.Subscribe.topic)
  return topic_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Subscribe::set_allocated_topic(std::string* topic) {
  if (topic != nullptr) {
    
  } else {
    
  }
  topic_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), topic,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pb.Subscribe.topic)
}

// uint32 bucket = 4 [deprecated = true];
inline void Subscribe::clear_bucket() {
  bucket_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Subscribe::_internal_bucket() const {
  return bucket_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Subscribe::bucket() const {
  // @@protoc_insertion_point(field_get:pb.Subscribe.bucket)
  return _internal_bucket();
}
inline void Subscribe::_internal_set_bucket(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  bucket_ = value;
}
inline void Subscribe::set_bucket(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_bucket(value);
  // @@protoc_insertion_point(field_set:pb.Subscribe.bucket)
}

// uint32 duration = 5;
inline void Subscribe::clear_duration() {
  duration_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Subscribe::_internal_duration() const {
  return duration_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Subscribe::duration() const {
  // @@protoc_insertion_point(field_get:pb.Subscribe.duration)
  return _internal_duration();
}
inline void Subscribe::_internal_set_duration(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  duration_ = value;
}
inline void Subscribe::set_duration(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:pb.Subscribe.duration)
}

// bytes meta = 6;
inline void Subscribe::clear_meta() {
  meta_.ClearToEmpty();
}
inline const std::string& Subscribe::meta() const {
  // @@protoc_insertion_point(field_get:pb.Subscribe.meta)
  return _internal_meta();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Subscribe::set_meta(ArgT0&& arg0, ArgT... args) {
 
 meta_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.Subscribe.meta)
}
inline std::string* Subscribe::mutable_meta() {
  std::string* _s = _internal_mutable_meta();
  // @@protoc_insertion_point(field_mutable:pb.Subscribe.meta)
  return _s;
}
inline const std::string& Subscribe::_internal_meta() const {
  return meta_.Get();
}
inline void Subscribe::_internal_set_meta(const std::string& value) {
  
  meta_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Subscribe::_internal_mutable_meta() {
  
  return meta_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Subscribe::release_meta() {
  // @@protoc_insertion_point(field_release:pb.Subscribe.meta)
  return meta_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Subscribe::set_allocated_meta(std::string* meta) {
  if (meta != nullptr) {
    
  } else {
    
  }
  meta_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), meta,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pb.Subscribe.meta)
}

// -------------------------------------------------------------------

// Unsubscribe

// bytes subscriber = 1;
inline void Unsubscribe::clear_subscriber() {
  subscriber_.ClearToEmpty();
}
inline const std::string& Unsubscribe::subscriber() const {
  // @@protoc_insertion_point(field_get:pb.Unsubscribe.subscriber)
  return _internal_subscriber();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Unsubscribe::set_subscriber(ArgT0&& arg0, ArgT... args) {
 
 subscriber_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.Unsubscribe.subscriber)
}
inline std::string* Unsubscribe::mutable_subscriber() {
  std::string* _s = _internal_mutable_subscriber();
  // @@protoc_insertion_point(field_mutable:pb.Unsubscribe.subscriber)
  return _s;
}
inline const std::string& Unsubscribe::_internal_subscriber() const {
  return subscriber_.Get();
}
inline void Unsubscribe::_internal_set_subscriber(const std::string& value) {
  
  subscriber_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Unsubscribe::_internal_mutable_subscriber() {
  
  return subscriber_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Unsubscribe::release_subscriber() {
  // @@protoc_insertion_point(field_release:pb.Unsubscribe.subscriber)
  return subscriber_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Unsubscribe::set_allocated_subscriber(std::string* subscriber) {
  if (subscriber != nullptr) {
    
  } else {
    
  }
  subscriber_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), subscriber,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pb.Unsubscribe.subscriber)
}

// string identifier = 2;
inline void Unsubscribe::clear_identifier() {
  identifier_.ClearToEmpty();
}
inline const std::string& Unsubscribe::identifier() const {
  // @@protoc_insertion_point(field_get:pb.Unsubscribe.identifier)
  return _internal_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Unsubscribe::set_identifier(ArgT0&& arg0, ArgT... args) {
 
 identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.Unsubscribe.identifier)
}
inline std::string* Unsubscribe::mutable_identifier() {
  std::string* _s = _internal_mutable_identifier();
  // @@protoc_insertion_point(field_mutable:pb.Unsubscribe.identifier)
  return _s;
}
inline const std::string& Unsubscribe::_internal_identifier() const {
  return identifier_.Get();
}
inline void Unsubscribe::_internal_set_identifier(const std::string& value) {
  
  identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Unsubscribe::_internal_mutable_identifier() {
  
  return identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Unsubscribe::release_identifier() {
  // @@protoc_insertion_point(field_release:pb.Unsubscribe.identifier)
  return identifier_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Unsubscribe::set_allocated_identifier(std::string* identifier) {
  if (identifier != nullptr) {
    
  } else {
    
  }
  identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), identifier,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pb.Unsubscribe.identifier)
}

// string topic = 3;
inline void Unsubscribe::clear_topic() {
  topic_.ClearToEmpty();
}
inline const std::string& Unsubscribe::topic() const {
  // @@protoc_insertion_point(field_get:pb.Unsubscribe.topic)
  return _internal_topic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Unsubscribe::set_topic(ArgT0&& arg0, ArgT... args) {
 
 topic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.Unsubscribe.topic)
}
inline std::string* Unsubscribe::mutable_topic() {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:pb.Unsubscribe.topic)
  return _s;
}
inline const std::string& Unsubscribe::_internal_topic() const {
  return topic_.Get();
}
inline void Unsubscribe::_internal_set_topic(const std::string& value) {
  
  topic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Unsubscribe::_internal_mutable_topic() {
  
  return topic_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Unsubscribe::release_topic() {
  // @@protoc_insertion_point(field_release:pb.Unsubscribe.topic)
  return topic_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Unsubscribe::set_allocated_topic(std::string* topic) {
  if (topic != nullptr) {
    
  } else {
    
  }
  topic_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), topic,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pb.Unsubscribe.topic)
}

// -------------------------------------------------------------------

// TransferAsset

// bytes sender = 1;
inline void TransferAsset::clear_sender() {
  sender_.ClearToEmpty();
}
inline const std::string& TransferAsset::sender() const {
  // @@protoc_insertion_point(field_get:pb.TransferAsset.sender)
  return _internal_sender();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransferAsset::set_sender(ArgT0&& arg0, ArgT... args) {
 
 sender_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.TransferAsset.sender)
}
inline std::string* TransferAsset::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:pb.TransferAsset.sender)
  return _s;
}
inline const std::string& TransferAsset::_internal_sender() const {
  return sender_.Get();
}
inline void TransferAsset::_internal_set_sender(const std::string& value) {
  
  sender_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransferAsset::_internal_mutable_sender() {
  
  return sender_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransferAsset::release_sender() {
  // @@protoc_insertion_point(field_release:pb.TransferAsset.sender)
  return sender_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransferAsset::set_allocated_sender(std::string* sender) {
  if (sender != nullptr) {
    
  } else {
    
  }
  sender_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sender,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pb.TransferAsset.sender)
}

// bytes recipient = 2;
inline void TransferAsset::clear_recipient() {
  recipient_.ClearToEmpty();
}
inline const std::string& TransferAsset::recipient() const {
  // @@protoc_insertion_point(field_get:pb.TransferAsset.recipient)
  return _internal_recipient();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransferAsset::set_recipient(ArgT0&& arg0, ArgT... args) {
 
 recipient_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.TransferAsset.recipient)
}
inline std::string* TransferAsset::mutable_recipient() {
  std::string* _s = _internal_mutable_recipient();
  // @@protoc_insertion_point(field_mutable:pb.TransferAsset.recipient)
  return _s;
}
inline const std::string& TransferAsset::_internal_recipient() const {
  return recipient_.Get();
}
inline void TransferAsset::_internal_set_recipient(const std::string& value) {
  
  recipient_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransferAsset::_internal_mutable_recipient() {
  
  return recipient_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransferAsset::release_recipient() {
  // @@protoc_insertion_point(field_release:pb.TransferAsset.recipient)
  return recipient_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransferAsset::set_allocated_recipient(std::string* recipient) {
  if (recipient != nullptr) {
    
  } else {
    
  }
  recipient_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), recipient,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pb.TransferAsset.recipient)
}

// int64 amount = 3;
inline void TransferAsset::clear_amount() {
  amount_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TransferAsset::_internal_amount() const {
  return amount_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TransferAsset::amount() const {
  // @@protoc_insertion_point(field_get:pb.TransferAsset.amount)
  return _internal_amount();
}
inline void TransferAsset::_internal_set_amount(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  amount_ = value;
}
inline void TransferAsset::set_amount(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:pb.TransferAsset.amount)
}

// -------------------------------------------------------------------

// GenerateID

// bytes public_key = 1;
inline void GenerateID::clear_public_key() {
  public_key_.ClearToEmpty();
}
inline const std::string& GenerateID::public_key() const {
  // @@protoc_insertion_point(field_get:pb.GenerateID.public_key)
  return _internal_public_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GenerateID::set_public_key(ArgT0&& arg0, ArgT... args) {
 
 public_key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.GenerateID.public_key)
}
inline std::string* GenerateID::mutable_public_key() {
  std::string* _s = _internal_mutable_public_key();
  // @@protoc_insertion_point(field_mutable:pb.GenerateID.public_key)
  return _s;
}
inline const std::string& GenerateID::_internal_public_key() const {
  return public_key_.Get();
}
inline void GenerateID::_internal_set_public_key(const std::string& value) {
  
  public_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GenerateID::_internal_mutable_public_key() {
  
  return public_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GenerateID::release_public_key() {
  // @@protoc_insertion_point(field_release:pb.GenerateID.public_key)
  return public_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GenerateID::set_allocated_public_key(std::string* public_key) {
  if (public_key != nullptr) {
    
  } else {
    
  }
  public_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), public_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pb.GenerateID.public_key)
}

// int64 registration_fee = 2;
inline void GenerateID::clear_registration_fee() {
  registration_fee_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GenerateID::_internal_registration_fee() const {
  return registration_fee_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GenerateID::registration_fee() const {
  // @@protoc_insertion_point(field_get:pb.GenerateID.registration_fee)
  return _internal_registration_fee();
}
inline void GenerateID::_internal_set_registration_fee(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  registration_fee_ = value;
}
inline void GenerateID::set_registration_fee(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_registration_fee(value);
  // @@protoc_insertion_point(field_set:pb.GenerateID.registration_fee)
}

// bytes sender = 3;
inline void GenerateID::clear_sender() {
  sender_.ClearToEmpty();
}
inline const std::string& GenerateID::sender() const {
  // @@protoc_insertion_point(field_get:pb.GenerateID.sender)
  return _internal_sender();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GenerateID::set_sender(ArgT0&& arg0, ArgT... args) {
 
 sender_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.GenerateID.sender)
}
inline std::string* GenerateID::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:pb.GenerateID.sender)
  return _s;
}
inline const std::string& GenerateID::_internal_sender() const {
  return sender_.Get();
}
inline void GenerateID::_internal_set_sender(const std::string& value) {
  
  sender_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GenerateID::_internal_mutable_sender() {
  
  return sender_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GenerateID::release_sender() {
  // @@protoc_insertion_point(field_release:pb.GenerateID.sender)
  return sender_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GenerateID::set_allocated_sender(std::string* sender) {
  if (sender != nullptr) {
    
  } else {
    
  }
  sender_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sender,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pb.GenerateID.sender)
}

// int32 version = 4;
inline void GenerateID::clear_version() {
  version_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GenerateID::_internal_version() const {
  return version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GenerateID::version() const {
  // @@protoc_insertion_point(field_get:pb.GenerateID.version)
  return _internal_version();
}
inline void GenerateID::_internal_set_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  version_ = value;
}
inline void GenerateID::set_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:pb.GenerateID.version)
}

// -------------------------------------------------------------------

// NanoPay

// bytes sender = 1;
inline void NanoPay::clear_sender() {
  sender_.ClearToEmpty();
}
inline const std::string& NanoPay::sender() const {
  // @@protoc_insertion_point(field_get:pb.NanoPay.sender)
  return _internal_sender();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NanoPay::set_sender(ArgT0&& arg0, ArgT... args) {
 
 sender_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.NanoPay.sender)
}
inline std::string* NanoPay::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:pb.NanoPay.sender)
  return _s;
}
inline const std::string& NanoPay::_internal_sender() const {
  return sender_.Get();
}
inline void NanoPay::_internal_set_sender(const std::string& value) {
  
  sender_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NanoPay::_internal_mutable_sender() {
  
  return sender_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NanoPay::release_sender() {
  // @@protoc_insertion_point(field_release:pb.NanoPay.sender)
  return sender_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NanoPay::set_allocated_sender(std::string* sender) {
  if (sender != nullptr) {
    
  } else {
    
  }
  sender_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sender,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pb.NanoPay.sender)
}

// bytes recipient = 2;
inline void NanoPay::clear_recipient() {
  recipient_.ClearToEmpty();
}
inline const std::string& NanoPay::recipient() const {
  // @@protoc_insertion_point(field_get:pb.NanoPay.recipient)
  return _internal_recipient();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NanoPay::set_recipient(ArgT0&& arg0, ArgT... args) {
 
 recipient_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.NanoPay.recipient)
}
inline std::string* NanoPay::mutable_recipient() {
  std::string* _s = _internal_mutable_recipient();
  // @@protoc_insertion_point(field_mutable:pb.NanoPay.recipient)
  return _s;
}
inline const std::string& NanoPay::_internal_recipient() const {
  return recipient_.Get();
}
inline void NanoPay::_internal_set_recipient(const std::string& value) {
  
  recipient_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NanoPay::_internal_mutable_recipient() {
  
  return recipient_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NanoPay::release_recipient() {
  // @@protoc_insertion_point(field_release:pb.NanoPay.recipient)
  return recipient_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NanoPay::set_allocated_recipient(std::string* recipient) {
  if (recipient != nullptr) {
    
  } else {
    
  }
  recipient_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), recipient,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pb.NanoPay.recipient)
}

// uint64 id = 3;
inline void NanoPay::clear_id() {
  id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NanoPay::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NanoPay::id() const {
  // @@protoc_insertion_point(field_get:pb.NanoPay.id)
  return _internal_id();
}
inline void NanoPay::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  id_ = value;
}
inline void NanoPay::set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:pb.NanoPay.id)
}

// int64 amount = 4;
inline void NanoPay::clear_amount() {
  amount_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 NanoPay::_internal_amount() const {
  return amount_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 NanoPay::amount() const {
  // @@protoc_insertion_point(field_get:pb.NanoPay.amount)
  return _internal_amount();
}
inline void NanoPay::_internal_set_amount(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  amount_ = value;
}
inline void NanoPay::set_amount(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:pb.NanoPay.amount)
}

// uint32 txn_expiration = 5;
inline void NanoPay::clear_txn_expiration() {
  txn_expiration_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 NanoPay::_internal_txn_expiration() const {
  return txn_expiration_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 NanoPay::txn_expiration() const {
  // @@protoc_insertion_point(field_get:pb.NanoPay.txn_expiration)
  return _internal_txn_expiration();
}
inline void NanoPay::_internal_set_txn_expiration(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  txn_expiration_ = value;
}
inline void NanoPay::set_txn_expiration(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_txn_expiration(value);
  // @@protoc_insertion_point(field_set:pb.NanoPay.txn_expiration)
}

// uint32 nano_pay_expiration = 6;
inline void NanoPay::clear_nano_pay_expiration() {
  nano_pay_expiration_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 NanoPay::_internal_nano_pay_expiration() const {
  return nano_pay_expiration_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 NanoPay::nano_pay_expiration() const {
  // @@protoc_insertion_point(field_get:pb.NanoPay.nano_pay_expiration)
  return _internal_nano_pay_expiration();
}
inline void NanoPay::_internal_set_nano_pay_expiration(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  nano_pay_expiration_ = value;
}
inline void NanoPay::set_nano_pay_expiration(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_nano_pay_expiration(value);
  // @@protoc_insertion_point(field_set:pb.NanoPay.nano_pay_expiration)
}

// -------------------------------------------------------------------

// IssueAsset

// bytes sender = 1;
inline void IssueAsset::clear_sender() {
  sender_.ClearToEmpty();
}
inline const std::string& IssueAsset::sender() const {
  // @@protoc_insertion_point(field_get:pb.IssueAsset.sender)
  return _internal_sender();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IssueAsset::set_sender(ArgT0&& arg0, ArgT... args) {
 
 sender_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.IssueAsset.sender)
}
inline std::string* IssueAsset::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:pb.IssueAsset.sender)
  return _s;
}
inline const std::string& IssueAsset::_internal_sender() const {
  return sender_.Get();
}
inline void IssueAsset::_internal_set_sender(const std::string& value) {
  
  sender_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IssueAsset::_internal_mutable_sender() {
  
  return sender_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IssueAsset::release_sender() {
  // @@protoc_insertion_point(field_release:pb.IssueAsset.sender)
  return sender_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IssueAsset::set_allocated_sender(std::string* sender) {
  if (sender != nullptr) {
    
  } else {
    
  }
  sender_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sender,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pb.IssueAsset.sender)
}

// string name = 2;
inline void IssueAsset::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& IssueAsset::name() const {
  // @@protoc_insertion_point(field_get:pb.IssueAsset.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IssueAsset::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.IssueAsset.name)
}
inline std::string* IssueAsset::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:pb.IssueAsset.name)
  return _s;
}
inline const std::string& IssueAsset::_internal_name() const {
  return name_.Get();
}
inline void IssueAsset::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IssueAsset::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IssueAsset::release_name() {
  // @@protoc_insertion_point(field_release:pb.IssueAsset.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IssueAsset::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pb.IssueAsset.name)
}

// string symbol = 3;
inline void IssueAsset::clear_symbol() {
  symbol_.ClearToEmpty();
}
inline const std::string& IssueAsset::symbol() const {
  // @@protoc_insertion_point(field_get:pb.IssueAsset.symbol)
  return _internal_symbol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IssueAsset::set_symbol(ArgT0&& arg0, ArgT... args) {
 
 symbol_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.IssueAsset.symbol)
}
inline std::string* IssueAsset::mutable_symbol() {
  std::string* _s = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:pb.IssueAsset.symbol)
  return _s;
}
inline const std::string& IssueAsset::_internal_symbol() const {
  return symbol_.Get();
}
inline void IssueAsset::_internal_set_symbol(const std::string& value) {
  
  symbol_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IssueAsset::_internal_mutable_symbol() {
  
  return symbol_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IssueAsset::release_symbol() {
  // @@protoc_insertion_point(field_release:pb.IssueAsset.symbol)
  return symbol_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IssueAsset::set_allocated_symbol(std::string* symbol) {
  if (symbol != nullptr) {
    
  } else {
    
  }
  symbol_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), symbol,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pb.IssueAsset.symbol)
}

// int64 total_supply = 4;
inline void IssueAsset::clear_total_supply() {
  total_supply_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IssueAsset::_internal_total_supply() const {
  return total_supply_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IssueAsset::total_supply() const {
  // @@protoc_insertion_point(field_get:pb.IssueAsset.total_supply)
  return _internal_total_supply();
}
inline void IssueAsset::_internal_set_total_supply(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  total_supply_ = value;
}
inline void IssueAsset::set_total_supply(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_total_supply(value);
  // @@protoc_insertion_point(field_set:pb.IssueAsset.total_supply)
}

// uint32 precision = 5;
inline void IssueAsset::clear_precision() {
  precision_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IssueAsset::_internal_precision() const {
  return precision_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IssueAsset::precision() const {
  // @@protoc_insertion_point(field_get:pb.IssueAsset.precision)
  return _internal_precision();
}
inline void IssueAsset::_internal_set_precision(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  precision_ = value;
}
inline void IssueAsset::set_precision(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_precision(value);
  // @@protoc_insertion_point(field_set:pb.IssueAsset.precision)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::pb::PayloadType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::PayloadType>() {
  return ::pb::PayloadType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_pb_2ftransaction_2eproto
